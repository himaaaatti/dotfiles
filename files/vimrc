"himaaaatti's vimrc

"encoding
set encoding=utf-8
set fileencodings=utf-8,sjis,cp932,euc-jp
set fileformats=unix,mac,dos

"backSpace
set backspace=start,eol,indent
set backspace=2

"colorscheme
colorscheme 256-jungle
syntax on

"tab
set expandtab
set shiftwidth=4
set smarttab
set softtabstop=4
set tabstop=4

"status line
set laststatus=2
set statusline=%F%r%=
" set statusline+=%
" set statusline +=\ % { noscrollbar #statusline() }
set statusline+=\ [%n]
set statusline+=\ (%l,%c)

"appearance
set number
set title
set cursorline
set cmdheight=1
set scrolloff=3
set showmatch
set matchtime=1
set showcmd
set showmode

"TODO:おそい ricty
highlight ZenkakuSpace cterm=underline ctermfg=lightblue guibg=#666666
au BufNewFile,BufRead * match ZenkakuSpace /　/

"search
set incsearch
set hlsearch
set ignorecase
set smartcase
set wildmenu
"file
set autoread

"other
set autoindent
set cindent
set history=1000
set undofile
set undodir=~/.vim/undo
set undolevels=1000
set noswapfile

"undo
set undodir=~/.vim/undodir
set undofile

"backup
set backupdir=~/.vim/backup
set backup
let &directory = &backupdir

"auto backup
autocmd BufWritePre,FileWritePre,FileAppendPre * call UpdateBackupFile()
function! UpdateBackupFile()
    let basedir = "$HOME/.vim/backup"
    let dir = strftime(basedir."/%Y%m/%d", localtime())
    if !isdirectory(dir)
        let retval = system("mkdir -p ".dir)
        let retval = system("chown username:groupname ".dir)
    endif
    exe "set backupdir=".dir
    let time = strftime("%H_%M_%S", localtime())
    exe "set backupext=.".time
endfunction

"viminfo
set viminfo='50,\"1000,:0,n~/.vim/viminfo.txt

" ----- mark -----
nnoremap [Mark] <Nop>
nmap m [Mark]

if !exists('g:markrement_char')
    let g:markrement_char = [
    \     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    \     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    \ ]
endif
nnoremap <silent>[Mark]m :<C-u>call <SID>AutoMarkrement()<CR>
function! s:AutoMarkrement()
    if !exists('b:markrement_pos')
        let b:markrement_pos = 0
    else
        let b:markrement_pos = (b:markrement_pos + 1) % len(g:markrement_char)
    endif
    execute 'mark' g:markrement_char[b:markrement_pos]
    echo 'marked' g:markrement_char[b:markrement_pos]
endfunction

nnoremap [Mark]n ]`
nnoremap [Mark]p [`

"set prefix key
let g:mapleader=","

nnoremap ZQ <Nop>
nnoremap Q gq
nnoremap <Space>w ZZ

nnoremap ; :
nnoremap : ;

nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k
nnoremap <S-Left> <C-w><<CR>
nnoremap <S-Right> <C-w>><CR>
nnoremap <S-Up> <C-w>-<CR>
nnoremap <S-Down> <C-w>+<CR>

nnoremap <Tab> %
vnoremap <Tab> %

nnoremap <Space>h :<C-u>vertical belowright help<Space>
" nnoremap <silent> <Space>ht :tab help <C-R><C-W><CR>

nnoremap <Leader>ev :tabnew $MYVIMRC<CR>

"Tab
nnoremap <Space>n :tabnew<Space>
nnoremap <Space>j gT
nnoremap <Space>k gt
nnoremap gt <Nop>
nnoremap gT <Nop>

nnoremap <Space>tj :<C-u>tab stj <C-R>=expand('<cword>')<CR><CR>

"set clipboard+=unnamed
set clipboard=unnamedplus

" fold
set foldmethod=syntax

" tags
nnoremap <C-]> g<C-]> 

"-------------------------------
"   Plugin
"-------------------------------

if !isdirectory(expand('~/.vim/bundle/neobundle.vim'))
    echo 'No NeoBundle'
    syntax enable
    colorscheme desert
    finish
endif

if has('vim_starting')
    "  set runtimepath+=d:/tool/vim/.bundle/neobundle.vim
    "  "  call neobundle#rc(expand('d:/tool/vim/.bundle'))
    set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#begin()

NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'Shougo/vimproc',{
    \ 'build' : {
            \ 'unix' : 'make -f make_unix.mak',
            \ },
            \}

" --- list ---

NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/vimfiler.vim'
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'scrooloose/nerdcommenter'
NeoBundle 'vim-scripts/EnhCommentify.vim'
NeoBundle 'rhysd/clever-f.vim'
NeoBundle 'vim-scripts/vim-auto-save'
NeoBundle 'bling/vim-airline'
NeoBundle 'tacroe/unite-mark'
NeoBundle 'thinca/vim-quickrun'
NeoBundle 'tpope/vim-surround'
NeoBundle 'vim-scripts/TaskList.vim'
NeoBundle 'junkblocker/unite-tasklist'
" NeoBundle 'vim-scripts/a.vim'
" NeoBundle 'vim-scripts/c.vim'
NeoBundle 'rhysd/vim-clang-format'
NeoBundle 'sudo.vim'
NeoBundle 'mopp/smartnumber.vim'
NeoBundle 'groenewege/vim-less'
NeoBundle "scrooloose/syntastic"

NeoBundle 'kana/vim-smartchr'
NeoBundle 'kana/vim-smartinput'

NeoBundle 'thinca/vim-template'
NeoBundle 'mopp/next-alter.vim'


" For python
if has('python3') || has('python')
"     NeoBundle 'davidhalter/jedi-vim'
"     NeoBundle 'andviro/flake8-vim'
endif

"for vlb
NeoBundle 'innocentyknr/vim-vlb'



" --- list -- end ---
NeoBundle 'Shougo/unite.vim'

if has('lua')
    NeoBundle 'Shougo/neocomplete'
else
    NeoBundle 'Shougo/neocomplcache'
endif

call neobundle#end()
filetype plugin indent on

let g:unite_data_directory = expand('~/.vim/Unite')
let g:unite_source_history_yank_enable = 1
let g:unite_enable_start_insert = 1
let g:unite_enable_short_source_names = 1
let g:unite_split_rule = 'botright'
let g:unite_prompt = '>>'

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
"     nmap <buffer> <ESC> <Plug>(unite_exit)
    imap <buffer> <ESC> <Plug>(unite_exit)
endfunction

nnoremap [unite] <Nop>
nmap <Space>u [unite]

nnoremap <silent> <Space>y  :<C-u>Unite history/yank<CR>
nnoremap <silent> [unite]f  :<C-u>Unite file file_mru bookmark<CR>
nnoremap <silent> <Space>b  :<C-u>Unite buffer<CR>
nnoremap <silent> [unite]r  :<C-u>Unite file_mru<CR>
nnoremap <silent> [unite]ma  :<C-u>Unite mapping<CR>
nnoremap <silent> [unite]me  :<C-u>Unite output:message<CR>
nnoremap <silent> <Space>d  :<C-u>Unite tab<CR>
nnoremap [Mark]l :<C-u>Unite mark<CR>
"nnoremap <silent> [unite]mr :<C-u>Unite output:marks<CR>

"platina searcher
nnoremap <silent><Space>p :<C-u>Unite grep:. -buffer-name=search-buffer<CR>
"let g:unite_source_grep_default_opts = '-iRHn --exclude-from=tags'
let g:unite_source_grep_default_opts = '-iRHn'
if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nogroup --nocolor'
    let g:unite_source_grep_recursive_opt = ''
endif
" search current word
nnoremap <silent><Space>ap :<C-u>Unite grep:. -buffer-name=search-buffer<CR><C-R><C-W><CR>

if has('lua')
"NeoComplete
    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#sources#syntax#min_keyword_length = 2

    let g:neocomplete#sources#dictionary#dictionaries  =  {
    \ 'default' : '',
        \ 'php' : '~/.vim/dict/php.dict',
        \ 'c' : '~/.vim/dict/c.dict',
        \ 'cpp' : '~/.vim/dict/cpp.dict',
        \ 'java' : '~/.vim/dict/java.dict'
        \}

    inoremap <expr><C-g>    neocomplete#undo_completion()
    inoremap <expr><C-l>    neocomplete#complete_common_string()

"     inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
"     function! s:my_cr_function()
"       return neocomplete#close_popup() . "\<CR>"
"     endfunction

"     inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-e>  neocomplete#cancel_popup()

    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    if !exists('g:neocomplete#sources#omni#input_patterns')
        let g:neocomplete#sources#omni#input_patterns  =  {}
    endif

else
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_smart_case = 1

    let g:neocomplcache_min_keyword_length = 2
    let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

    let g:neocomplcache_dictionary_filetype_lists = {
    \ 'default' : '',
        \ 'php' : '~/.vim/dict/php.dict',
        \ 'c' : '~/.vim/dict/c.dict',
        \ 'cpp' : '~/.vim/dict/cpp.dict',
        \ 'java' : '~/.vim/dict/java.dict'
        \}

    inoremap <expr><C-g>    neocomplcache#undo_completion()
    inoremap <expr><C-l>    neocomplcache#complete_check()

"     inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
"     function! s:my_cr_function()
"       return neocomplcache#smart_close_popup() . "\<CR>"
      " For no inserting <CR> key.
      "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
"     endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
"     inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
"     inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplcache#close_popup()
    inoremap <expr><C-e>  neocomplcache#cancel_popup()


    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    if !exists('g:neocomplcache_omni_patterns')
      let g:neocomplcache_omni_patterns = {}
    endif
    let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#sources#syntax#min_keyword_length = 2

let g:neocomplete#sources#dictionary#dictionaries  =  {
    \ 'default' : '',
    \ 'php' : '~/.vim/dict/php.dict',
    \ 'c' : '~/.vim/dict/c.dict',
    \ 'cpp' : '~/.vim/dict/cpp.dict',
    \ 'java' : '~/.vim/dict/java.dict',
    \ 'scala' : '~/.vim/dict/scala.dict'
    \}

inoremap <expr><C-g>    neocomplete#undo_completion()
inoremap <expr><C-l>    neocomplete#complete_common_string()

" inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
" function! s:my_cr_function()
"   return neocomplete#close_popup() . "\<CR>"
" endfunction

" inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-e>  neocomplete#cancel_popup()

    " For perlomni.vim setting.
    " https://github.com/c9s/perlomni.vim
    let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

endif

"NeoSnnipet
imap <C-k>  <Plug>(neosnippet_expand_or_jump)
smap <C-k>  <Plug>(neosnippet_expand_or_jump)
xmap <C-k>  <Plug>(neosnippet_expand_target)
xmap <C-l>  <Plug>(neosnippet_start_unite_snippet_target)

"indent-guides
" let g:indent_guides_indent_levels=30
let g:indent_guides_start_level=2
let g:indent_guides_auto_colors=0
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_guide_size = 1
" hi IndentGuidesOdd  guibg=red   ctermbg=3
" hi IndentGuidesEven guibg=lightblue  ctermbg=4
hi IndentGuidesOdd ctermbg=183
hi IndentGuidesEven ctermbg=31
" let g:indent_guides_color_change_percent = 10

"Syntastic
" let g:syntastic_always_populate_loc_list = 1
" let g:syntastic_enable_signs = 1
" let g:syntastic_auto_loc_list = 2
" let g:syntastic_python_checkers = ['flake8']
"c++11
let g:syntastic_cpp_compiler = 'clang++'
let g:syntastic_cpp_compiler_options = '-std=c++11'

"EnhCommentify
let g:EnhCommentifyRespectIndent = 'No'
let g:EnhCommentifyPretty = 'Yes'
let g:EnhCommentifyUseBlockIndent = 'Yes'
let g:EnhCommentifyCommentsOp = 'yes'

"nerdcommenter
"let NERDSpaceDelims = 1
"nnoremap <Leader>x NERDCommenterToggle
"vnoremap <Leader>x NERDCommenterToggle

"Vim-Airline
let g:airline#extensions#tabline#enabled  =  1
let g:airline#extensions#syntastic#enabled = 1
let g:airline#extensions#tabline#show_buffers = 1


"QuickRun
let g:quickrun_config = {
    \   '_':{
\       'runner': 'vimproc',
\       'runner/vimproc/updatetime': 60,
\       'vsplit': '',
\       'hook/typt/enable': 1,
\       'outputter/buffer/close_on_empty': 1
\   },
\}

"Vim-Surround
"TODO:rhysd/vim-operator-surround

"Vim-AutoSave
let g:auto_save = 1

"VimFiler
" let g:vimfiler_edit_action = 'tabopen'
" let g:vimfiler_enable_auto_cd = 1
" nnoremap <Space>v :VimFiler -split -simple -winwidth=35 -quit<CR>
nnoremap <silent> <Space>v :<C-u>VimFiler -explorer<CR>

"clang-fomat
" let g:clang_format#command="clang-format-3.5"
let g:clang_format#command="clang-format"
let g:clang_format#code_style="chromium"
let g:clang_format#style_options = {
    \ "BreakBeforeBraces" : "Stroustrup",
    \ "AlwaysBreakTemplateDeclarations" : "true",
    \ "AccessModifierOffset" : -4,
    \ "Standard" : "C++11",
    \ "IndentWidth" : 4
    \}
" autocmd FileType c,cpp,objc nnoremap <Space>f vi{:ClangFormat<CR>
" autocmd FileType c,cpp,objc vnoremap <Space>f i{:ClangFormat<CR>

"a.vim
" nnoremap <Space>a :<C-u>AT<CR>

"unite-tasklist
nnoremap <Leader>T :<C-u>TaskList<CR>

"next-alter
" nnoremap <expr> <Space>l <Plug>(next-alter-open)
"y nnoremap <expr> <Leader>
nnoremap <Space>l :<C-u>OpenNAlter vertical<CR>

" vlb-vim
autocmd FileType vlb let g:neosnippet#snippets_directory='~/.vim/bundle/vim-vlb/snippet'
